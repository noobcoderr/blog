---
title:       "golang如何实现并发"
subtitle:    ""
description: ""
date:        2020-04-12
author:      我不道啊？
image:       ""
tags:        ["question_a_day"]
categories:  ["Tech" ]
---

# Golang如何实现并发？

## 头脑风暴

老生常谈，什么是并发？什么是并行？

进程、线程、协程的区别，goroutine属于哪一种，为什么？

为什么说golang是从语言级别实现的并发？难倒其他语言实现并发和golang有非常大 的不同？

golang是如何实现语言级别的并发的？

各种语言的程序是如何实现并发的？

计算机是如何支持并发的？

## 开始

首先，我们用各种编程语言编写的程序，点击运行的时候，在计算机上，其实是启动了一个进程的。

比如说我们写了一个非常简单的web服务，127.0.0.1:8080 启动后，它就是一个进程。底层会起一个socket监听808端口，当我们用浏览器请求时，最后数据包都进了这个端口，进了这个端口后，怎么处理呢？这应该就是各个语言的的处理范围了。

会直接让这个进程处理这个请求嘛？如果处理过程是耗时的，那么这个时候又进来许多请求怎么办？得等着呗，等上一个请求处理完，再处理后来的，所以不可能直接让主进程处理这些逻辑，那怎么办？

fork一个子进程出来处理？主进程只管为到来的请求fork出一个子进程来进行处理，每来一个请求，就fork一个进行进行处理，那确实解决了多个请求到来的问题，但是进程占用资源较多，这样下去，当请求较多的时候，那么这个机器的资源就被耗尽了。(进程池，进程没有进程池，线程有)

上一种方法太重量级了，那在主进程内起非常多的线程？是一个思路，一个线程占用内存大约1M，相对于进程来说，是非常轻量了。(线程的堆栈空间在windows下默认2M，linux下默认8M)

随着互联网的飞速发展，后来又出现了协程，是比线程更加轻量级，像goroutine，一个只占4k(难倒不需要上下文信息嘛？应该超过4K了吧？)。

他们是如何并发的呢？

创建好之后，轮番进入cpu执行一定的时间片，直到任务结束。并不是一个任务一直霸占cpu直到任务结束。(切换难倒不消耗性能嘛？一个任务执行到底和轮番切换执行，哪一种收益更高？)（这里还涉及到了进程的几种状态）

那CPU是如何调度的呢？这个是各自的语言相关的嘛？是属于语言去调度管理的嘛(基于用户空间，所以由开发者控制，如果是基于内核空间，则由系统控制)？



一切源于C10K，现在是C100K，C1000K，

现在常见的web都是IO密集，因为大多都是增删改查数据库操作，

当某个方法被阻塞了，该方法所在的线程会被挂起，被操作系统的调度器放到阻塞队列，直到 A 等待的事件发生，才从阻塞态转到就绪态。（这里还涉及到了进程的几种状态）

用户线程无法控制多任务并行跑在多核上，只有内核线程才可以控制使用。用户线程只能时间片轮训使用当前所在的核。

多线程需要内核线程和用户线程。

进程间通信，首先要明白，进程运行的时候，是个什么样的存在，为什么要和其它进程进行通信？再来思考进程间通信的其他知识点。

进程运行时，是个什么存在形式，比如你一想起人，就知道有胳膊，有腿，一个脑袋，能直立行走，会说话，会蹦会跳，有名字，家住哪，等等等等。(写这些就是为了我能方便记住这些枯燥的知识点。)

## 并发模型



## 参考文章

- [并发模型比较](https://cloud.tencent.com/developer/article/1349213)
- [这些并发模型你真的懂了吗？未必](https://learnku.com/articles/32807)

- [20 张动图为你演示 Go 并发](https://learnku.com/go/t/39490)

