---
title:       "并发"
subtitle:    ""
description: "并发？并发的难点？并发与golang？"
date:        2019-09-11
lastmod:     2019-09-18
author:      NoobCoder
image:       ""
tags:        ["并发"]
categories:  ["Tech" ]
---

# 并发

现在的程序员，交流一出口就是高并发，不会处理高并发或者没听过高并发甚至都不好意思开口。最近在用Golang开发，一说到Golang，又最快联想到的是其并发处理，那么到底什么是并发呢？Golang对并发的处理又有什么关系与优势呢？咱系统地梳理一遍

先说说我的个人理解(对不对没关系，总结完后再对比更正)。先说她的兄弟姐妹词，并行，串行。咱从字面意识来了解一波

**串行**：串成一行，想想一下糖葫芦或者行军的队伍，一前一后地往前走，

**并行**：想像一下两个人并排地走在路上往前走。

串行，并行强调的是前进的组织方式，是一前一后还是同时并排着前进，描述的是我怎么行走，是行为。

**并发**：N件事情一并发生，强调的是在这个时刻，多件事件的发生。描述的是一种现象。

并发描述的对象是谁？

以上就是我在没梳理并发知识的个人理解，接下来再从各渠道搜集知识整理整理看看区别

例子1：三个学院的学生分3个方向进操场，大伙儿都走到门口(那种得绕一下的门，一次只能过一个，别说我们学校操场还真是这样的，但是不是一次只能进一个，那个口是一个，但是分成了2边)了，但是操场只有一个入口，那咋进？3个学院一次一个，轮着进呗，公平公正。看起来三个队伍都在进去，但是同一时刻，门是只有一个学生走过的。

例子2：双十一，1秒内完成30w个订单请求，某一台主机难道是一直处理一个用户的请求从头到尾嘛？当然不是，当我们连接上，结账过程中还有输入密码过程呀，当我们输入密码的时候，或者说，当切到输入密码的一瞬间，其实机器的cpu早就去处理其他的请求去了。

不去搜网上资料好像还有点理解，看了几篇文章，感觉又蒙了。。。。摘录几条

> 在[操作系统](https://baike.baidu.com/item/操作系统)中，并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个[处理机](https://baike.baidu.com/item/处理机)上运行，但任一个时刻点上只有一个程序在处理机上运行。   来自百度百科

-

> 具体达到多少请求才算是高并发系统呢?这个也没有明确数量上的定义,根据网上很多大型互联网公司的相关高并发博客,一般PV在千万级别以上的公司才会涉及到这个概念,所以**如果某个系统的日PV在千万级别以上,可能是一个高并发系统**.这里根据具体业务不同,这个数字可能高或者低一些

## 背景

并发一般是随着高这个程度词一块出现的，高并发也是随着移动互联网的快速发展变的火热起来的。

最好的理解场景就是双十一，好多活动都是前几秒下单减免力度更大，所以人们都抢着那个时候结账，假设人数是30w(肯定不止，是每秒处理30w，肯定有超过30w的请求尽量，但是其服务器在这前1秒内处理了30w订单)，那么在刚到0点到0点01秒的那一瞬间，有30w个请求发送到了淘宝的服务器，并发说的就是这么个现象。

我们说高并发，其实讨论的是怎么去解决30w的并发以及带来的问题，比如订单号的生成，id的生成，会不会出现重复啊之类的安全问题，以及服务器如何抗住这么大的流量、数据库读写会不会出问题等等等等

>  双十一当晚0点，大概有4-5亿条数据/秒，每秒完成将进30w的订单，假设1000太机器，平均下来也得每台30000条的并发。

场景1：抢红包

场景2：12306过节春节放票、明星演唱会放票、电子竞技总决赛抢票

场景3：双十一秒杀抢满1000减1000券

## 并发会带来什么问题？

比如你只想在10点发100张满1000-500的无门槛优惠券，那肯定是会吸引很多人准备在10点前做好准备开抢的。假如现在有10000人看道了消息准备来抢这个券。

情况1：

你的代码设计最开始没那么高并发，设计为在redis内设置一个券数量100，来一个请求将券数量减1，如果券值小于等于0，那么返回券已被抢完的信息。当只有100个人来抢时，你的程序完全可以应付(其实 也不好说)，但是当刚过10点那一秒，有成千上万的请求涌入呢？会出现一个什么情况呢？

当某一个请求去查redis，发现券值为50，于是它去修改进行减一，但是期间有另外100多个人也 查了，是50，也都打算去改，最后都改成功了。那么发出的券的数量肯定超过了100，这直接超了预算，宣布取消活动？那生意也做不下去了，不取消？估计活动赚的都不够这次赔的。

带来的问题1就是造成数据的错乱

情况2：

针对上述情况你给redis加了个锁，先看锁的状态，只有获取了锁，才能对券值进行修改，修改完再释放锁。那这样，就保证了只有100个人可以修改券值了。那么这里一个问题，怎么保证锁时只能同时只能被一个人获取呢？这里先步讨论具体细节，只要知道这里是互斥锁，同时只能由一人操作。

这样，就可以把公共的资源变的更安全，因为众多请求到来时，得有锁才能对其进行操作，而不是肆意妄为地对公共资源进行减法，虽然这样阻塞了请求降低了性能。

## 怎么解决这些问题



